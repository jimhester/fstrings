#' Format and interpolate a string
#'
#' Expressions enclosed by braces will be evaluated as R code. Single braces
#' can be inserted by doubling them.
#' @param .x \[`listish`]\cr An environment, list or data frame used
#'   to lookup values.
#' @param ... \[`expressions`]\cr Expressions string(s) to format,
#'   multiple inputs are concatenated together before formatting.
#'   Strings are evaluated in `.envir` while expressions are evaluated
#'   in their original context. Expressions are evaluated from left to
#'   right.
#' @param .sep \[`character(1)`: \sQuote{""}]\cr Separator used to
#'   separate elements.
#' @param .envir \[`environment`: `parent.frame()`]\cr Environment to
#'   evaluate each string expression in. Symbolic expressions are
#'   always evaluated in their original context. Note that tidyeval
#'   idioms may be used to gain more control, e.g. unquoting a quosure
#'   enclosed in a specific environment. If `.x` is an environment,
#'   the expressions are evaluated in that environment and `.envir` is
#'   ignored.
#' @param .open \[`character(1)`: \sQuote{\\\{}]\cr The opening
#'   delimiter. Doubling the full delimiter escapes it.
#' @param .close \[`character(1)`: \sQuote{\\\}}]\cr The closing
#'   delimiter. Doubling the full delimiter escapes it.
#' @seealso <https://www.python.org/dev/peps/pep-0498/> and
#'   <https://www.python.org/dev/peps/pep-0257> upon which this is
#'   based.
#' @examples
#' name <- "Fred"
#' age <- 50
#' anniversary <- as.Date("1991-10-12")
#' glue('My name is {name},',
#'   'my age next year is {age + 1},',
#'   'my anniversary is {format(anniversary, "%A, %B %d, %Y")}.')
#'
#' # single braces can be inserted by doubling them
#' glue("My name is {name}, not {{name}}.")
#'
#' # Named arguments can also be supplied
#' glue('My name is {name},',
#'   ' my age next year is {age + 1},',
#'   ' my anniversary is {format(anniversary, "%A, %B %d, %Y")}.',
#'   name = "Joe",
#'   age = 40,
#'   anniversary = as.Date("2001-10-12"))
#'
#' # `glue_data()` is useful in magrittr pipes
#' library(magrittr)
#' mtcars %>% glue_data("{rownames(.)} has {hp} hp")
#'
#' # Alternative delimiters can also be used if needed
#' one <- "1"
#' glue("The value of $e^{2\\pi i}$ is $<<one>>$.", .open = "<<", .close = ">>")
#' @useDynLib glue glue_
#' @name glue
#' @import rlang
#' @export
glue_data <- function(.x, ..., .sep = "", .envir = parent.frame(), .open = "{", .close = "}") {

  args <- quos(...)
  named <- have_name(args)

  if (is_env(.x)) {
    overscope <- new_overscope(.x, env_tail(.x), enclosure = .x)
  } else {
    bottom <- env_bury(empty_env(), !!! .x %||% list())
    overscope <- new_overscope(bottom, enclosure = .envir)
  }

  overscope$.data <- as_dictionary(.x, read_only = TRUE)
  on.exit(overscope_clean(overscope))

  assign_args(args[named], overscope)

  unnamed_args <- eval_tidy(args[!named])

  lengths <- lengths(unnamed_args)
  if (any(lengths == 0)) {
    return(as_glue(character(0)))
  }
  if (any(lengths != 1)) {
    stop("All unnamed arguments must be length 1", call. = FALSE)
  }
  unnamed_args <- paste0(unnamed_args, collapse = .sep)
  unnamed_args <- trim(unnamed_args)

  # Parse any glue strings
  eval_fn <- function(e) {
    res <- overscope_eval_next(overscope, parse_quosure(e, .envir))
    enc2utf8(as.character(res))
  }
  res <- .Call(glue_, unnamed_args, eval_fn, .open, .close)

  if (any(lengths(res) == 0)) {
    return(as_glue(character(0)))
  }

  res <- do.call(paste0, recycle_columns(res))

  as_glue(res)
}

#' @export
#' @rdname glue
glue <- function(..., .sep = "", .envir = parent.frame(), .open = "{", .close = "}") {
  glue_data(.x = NULL, ..., .sep = .sep, .envir = .envir, .open = .open, .close = .close)
}

#' Collapse a character vector
#'
#' Collapses a character vector of any length into a length 1 vector.
#' @param x The character vector to collapse.
#' @param width The maximum string width before truncating with `...`.
#' @param last String used to separate the last two items if `x` has at least
#' 2 items.
#' @inheritParams base::paste
#' @examples
#' collapse(glue("{1:10}"))
#'
#' # Wide values can be truncated
#' collapse(glue("{1:10}"), width = 5)
#'
#' collapse(1:4, ",", last = " and ")
#' #> 1, 2, 3 and 4
#' @export
collapse <- function(x, sep = "", width = Inf, last = "") {
  if (length(x) == 0) {
    return(as_glue(character()))
  }
  if (nzchar(last) && length(x) > 1) {
    res <- collapse(x[seq(1, length(x) - 1)], sep = sep, width = Inf)
    return(collapse(glue(res, last, x[length(x)]), width = width))
  }
  x <- paste0(x, collapse = sep)
  if (width < Inf) {
    x_width <- nchar(x, "width")
    too_wide <- x_width > width
    if (too_wide) {
      x <- paste0(substr(x, 1, width - 3), "...")
    }
  }
  as_glue(x)
}

#' Trim a character vector
#'
#' This trims a character vector according to the trimming rules used by glue.
#' These follow similar rules to [Python Docstrings](https://www.python.org/dev/peps/pep-0257),
#' with the following features.
#'
#' - Leading and trailing whitespace from the first and last lines is removed.
#' - A uniform amount of indentation is stripped from the second line on, equal
#' to the minimum indentation of all non-blank lines after the first.
#' - Lines can be continued across newlines by using `\\`.
#' @param x A character vector to trim.
#' @examples
#' glue("
#'     A formatted string
#'     Can have multiple lines
#'       with additional indention preserved
#'     ")
#'
#' glue("
#'   \\ntrailing or leading newlines can be added explicitly\\n
#'   ")
#'
#' glue("
#'     A formatted string \\
#'     can also be on a \\
#'     single line
#'     ")

#' @useDynLib glue trim_
trim <- function(x) {
  .Call(trim_, x)
}

#' @export
print.glue <- function(x, ..., sep = "\n") {
  cat(x, ..., sep = sep)

  invisible(x)
}

#' Coerce object to glue
#' @param x object to be coerced.
#' @param ... further arguments passed to methods.
#' @export
as_glue <- function(x, ...) {
  UseMethod("as_glue")
}

#' @export
as_glue.default <- function(x, ...) {
  as_glue(as.character(x))
}

#' @export
as_glue.glue <- function(x, ...) {
  x
}

#' @export
as_glue.character <- function(x, ...) {
  structure(x, class = c("glue", "character"))
}

#' @export
as.character.glue <- function(x, ...) {
  unclass(x)
}

#' @importFrom methods setOldClass

setOldClass(c("glue", "character"))
